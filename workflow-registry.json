{
  "version": "2.0",
  "schemaVersion": 2,
  "lastUpdated": "2026-02-19T15:30:00Z",
  "nodeWhitelist": [
    "n8n-nodes-base.executeWorkflowTrigger",
    "n8n-nodes-base.set",
    "n8n-nodes-base.code",
    "n8n-nodes-base.httpRequest",
    "n8n-nodes-base.gmail",
    "n8n-nodes-base.googleCalendar",
    "n8n-nodes-base.merge",
    "n8n-nodes-base.if",
    "n8n-nodes-base.switch",
    "n8n-nodes-base.noOp"
  ],
  "workflows": {
    "Email.Send": {
      "n8nId": "0G0Ka32a3mYhQhOa",
      "description": "Send an email via Gmail",
      "input": {
        "to":      { "type": "string",  "required": true,  "description": "Recipient email address(es), comma-separated" },
        "subject": { "type": "string",  "required": true,  "description": "Email subject line" },
        "body":    { "type": "string",  "required": true,  "description": "Email body (plain text or HTML)" },
        "cc":      { "type": "string",  "required": false, "description": "CC recipients, comma-separated" },
        "bcc":     { "type": "string",  "required": false, "description": "BCC recipients, comma-separated" }
      },
      "output": {
        "messageId": { "type": "string", "description": "Gmail message ID" },
        "threadId":  { "type": "string", "description": "Gmail thread ID" },
        "status":    { "type": "string", "enum": ["sent", "error"], "description": "Result status" }
      },
      "tags": ["email", "gmail", "send"],
      "credentialRef": "gmail_main",
      "semanticDescription": "Composes and delivers a new outbound email message to one or more recipients via the Gmail API, supporting plain text or HTML body content. Use this workflow when the goal is to send a brand-new message to an address. Do NOT use this for replying to an existing thread — use Email.Reply instead. Requires recipient address, subject, and body; CC and BCC are optional.",
      "status": "active",
      "version": 1,
      "createdBy": "human",
      "nodeHash": null,
      "usageCount": 0,
      "lastVerified": "2026-02-19T00:00:00Z",
      "dependsOn": [],
      "allowedCallers": "any"
    },
    "Email.Get": {
      "n8nId": "GxrpXyYs4TmWtCXQ",
      "description": "Get a single email by message ID",
      "input": {
        "messageId": { "type": "string", "required": true, "description": "Gmail message ID to retrieve" }
      },
      "output": {
        "messageId": { "type": "string", "description": "Gmail message ID" },
        "threadId":  { "type": "string", "description": "Gmail thread ID" },
        "from":      { "type": "string", "description": "Sender email address" },
        "to":        { "type": "string", "description": "Recipient email address(es)" },
        "subject":   { "type": "string", "description": "Email subject line" },
        "body":      { "type": "string", "description": "Email body text" },
        "date":      { "type": "string", "description": "Email date (ISO 8601)" },
        "labels":    { "type": "array",  "description": "Array of label IDs on this message" }
      },
      "tags": ["email", "gmail", "get", "read"],
      "credentialRef": "gmail_main",
      "semanticDescription": "Retrieves a single Gmail message by its message ID and returns the full parsed content including sender, recipient, subject, body text, date, and current label IDs. Use this when you have a known message ID and need the complete details of that specific email. For browsing or finding messages without a known ID, use Email.List or Email.Search instead. Returns a fully-parsed message object with all header fields at the top level.",
      "status": "active",
      "version": 1,
      "createdBy": "human",
      "nodeHash": null,
      "usageCount": 0,
      "lastVerified": "2026-02-19T00:00:00Z",
      "dependsOn": [],
      "allowedCallers": "any"
    },
    "Email.List": {
      "n8nId": "90vLGzH19vJNqVc1",
      "description": "List recent emails from Gmail inbox",
      "input": {
        "limit":    { "type": "number", "required": false, "description": "Max emails to return (default 10, max 50)" },
        "labelIds": { "type": "string", "required": false, "description": "Filter by label ID (e.g. INBOX, UNREAD)" },
        "query":    { "type": "string", "required": false, "description": "Gmail search query (e.g. 'is:unread')" }
      },
      "output": {
        "messages": { "type": "array", "description": "Array of {messageId, from, subject, snippet, date}" }
      },
      "tags": ["email", "gmail", "list", "inbox"],
      "credentialRef": "gmail_main",
      "semanticDescription": "Returns a paginated list of recent emails from Gmail with summary fields (message ID, sender, subject, snippet, date) for each message. Use this for browsing recent mail, checking what's in the inbox, or getting an overview without knowing specific message IDs. All inputs are optional — calling with no parameters returns the 10 most recent inbox messages. For targeted searching by content or sender, prefer Email.Search instead.",
      "status": "active",
      "version": 1,
      "createdBy": "human",
      "nodeHash": null,
      "usageCount": 0,
      "lastVerified": "2026-02-19T00:00:00Z",
      "dependsOn": [],
      "allowedCallers": "any"
    },
    "Email.Search": {
      "n8nId": "1RQlpK2HU3Cu4qKC",
      "description": "Search emails using Gmail query syntax",
      "input": {
        "query": { "type": "string", "required": true,  "description": "Gmail search query (e.g. 'from:user@example.com subject:invoice')" },
        "limit": { "type": "number", "required": false, "description": "Max results to return (default 10, max 50)" }
      },
      "output": {
        "messages": { "type": "array", "description": "Array of {messageId, from, subject, snippet, date}" }
      },
      "tags": ["email", "gmail", "search", "query"],
      "credentialRef": "gmail_main",
      "semanticDescription": "Searches Gmail using the full Gmail query syntax (e.g. 'from:boss@company.com subject:invoice is:unread after:2026/01/01') and returns matching messages as summary objects. Use this when you need to find specific emails by content, sender, date range, or any other Gmail-supported filter criterion. Unlike Email.List which browses recent mail, Email.Search targets a precise subset. Requires a query string; results are summaries — fetch a full message with Email.Get if the body is needed.",
      "status": "active",
      "version": 1,
      "createdBy": "human",
      "nodeHash": null,
      "usageCount": 0,
      "lastVerified": "2026-02-19T00:00:00Z",
      "dependsOn": [],
      "allowedCallers": "any"
    },
    "Email.Label": {
      "n8nId": "oBbkedhulUupMiNU",
      "description": "Add or remove labels on a Gmail message",
      "input": {
        "messageId":    { "type": "string", "required": true,  "description": "Gmail message ID to modify" },
        "addLabels":    { "type": "array",  "required": false, "description": "Label IDs to add (e.g. ['STARRED', 'IMPORTANT'])" },
        "removeLabels": { "type": "array",  "required": false, "description": "Label IDs to remove (e.g. ['UNREAD'])" }
      },
      "output": {
        "messageId":     { "type": "string", "description": "Gmail message ID" },
        "currentLabels": { "type": "array",  "description": "Labels currently on the message after modification" },
        "status":        { "type": "string", "enum": ["updated", "error"], "description": "Result status" }
      },
      "tags": ["email", "gmail", "label", "organize"],
      "credentialRef": "gmail_main",
      "semanticDescription": "Adds and/or removes Gmail label IDs on a specific message, then returns the message's updated label set. Use this to mark messages as read/unread, star them, apply custom organizational labels, or move them between categories. Requires the message ID; at least one of addLabels or removeLabels should be provided. This workflow calls the Gmail modify API directly via HTTP Request since the native Gmail node does not support label modification.",
      "status": "active",
      "version": 1,
      "createdBy": "human",
      "nodeHash": null,
      "usageCount": 0,
      "lastVerified": "2026-02-19T00:00:00Z",
      "dependsOn": [],
      "allowedCallers": "any"
    },
    "Email.Reply": {
      "n8nId": "OMahM1prJ6QecQ2Y",
      "description": "Reply to an existing email thread",
      "input": {
        "messageId": { "type": "string", "required": true,  "description": "Gmail message ID to reply to" },
        "body":      { "type": "string", "required": true,  "description": "Reply body (plain text or HTML)" }
      },
      "output": {
        "newMessageId": { "type": "string", "description": "New reply message ID" },
        "threadId":     { "type": "string", "description": "Gmail thread ID" },
        "status":       { "type": "string", "enum": ["sent", "error"], "description": "Result status" }
      },
      "tags": ["email", "gmail", "reply", "respond"],
      "credentialRef": "gmail_main",
      "semanticDescription": "Sends a reply to an existing Gmail thread, preserving thread context by referencing the original message ID. Use this when continuing a conversation — it correctly sets the In-Reply-To and References headers so the reply appears in the same thread. Do NOT use this for composing a new standalone message — use Email.Send instead. Requires the message ID of the email being replied to and the reply body text.",
      "status": "active",
      "version": 1,
      "createdBy": "human",
      "nodeHash": null,
      "usageCount": 0,
      "lastVerified": "2026-02-19T00:00:00Z",
      "dependsOn": [],
      "allowedCallers": "any"
    },
    "Email.Sort": {
      "n8nId": "E9fL6eEwZGZg6RNB",
      "description": "Classify unread inbox emails using local Qwen3 LLM and apply NEXUS_LABELS",
      "input": {},
      "output": {
        "status":       { "type": "string", "description": "ok" },
        "sorted_count": { "type": "number", "description": "Number of emails sorted" },
        "sorted":       { "type": "array",  "description": "Array of {messageId, subject, label}" }
      },
      "triggers": ["schedule (every 15 min)", "webhook POST /webhook/email-sort"],
      "tags": ["email", "gmail", "sort", "classify", "llm", "qwen"],
      "credentialRef": "gmail_main",
      "llm": { "model": "Qwen3-4B-noFP", "endpoint": "http://192.168.1.251:8000", "purpose": "classification" },
      "semanticDescription": "Scans the Gmail inbox for unread messages and classifies each one into a NEXUS_LABELS category (urgent, financial, legal, personal, kids, project, or junk) using a locally-hosted Qwen3-4B language model running on the Brainstem node. Applies the appropriate Gmail label to each message and returns a count and list of sorted messages. This workflow takes no inputs — it operates on the current inbox state. Triggered automatically on a 15-minute schedule or on-demand via webhook.",
      "status": "active",
      "version": 1,
      "createdBy": "human",
      "nodeHash": null,
      "usageCount": 0,
      "lastVerified": "2026-02-19T00:00:00Z",
      "dependsOn": [],
      "allowedCallers": "any"
    },
    "LLM.Council": {
      "n8nId": "13Bg7qtxJYvsFscJ",
      "description": "Multi-model deliberation: Claude + Gemini + GPT reason together, vote, and synthesize consensus via a 2-round structured debate",
      "input": {
        "question": { "type": "string", "required": true, "description": "The question or prompt for the Council to deliberate on" }
      },
      "output": {
        "question":         { "type": "string",  "description": "Original question passed in" },
        "final_answer":     { "type": "string",  "description": "Synthesized consensus answer from the majority" },
        "consensus":        { "type": "string",  "enum": ["unanimous", "majority", "split"], "description": "How much agreement was reached" },
        "vote_tally":       { "type": "object",  "description": "Vote counts per option, e.g. {yes: 2, no: 1}" },
        "confidence":       { "type": "number",  "description": "Domain-fit-weighted confidence of agreeing models (0–1)" },
        "rounds_completed": { "type": "number",  "description": "1 if R2 was skipped (unanimous + low variance), 2 if peer review ran" },
        "questions_for_user": { "type": "array", "description": "Aggregated clarifying questions for the user across all models" },
        "action_items":     { "type": "array",   "description": "Merged, deduplicated action items from all models" },
        "dissent":          { "type": "object",  "description": "Outvoted model's identity and dissent note (null if unanimous)" },
        "deliberation":     { "type": "array",   "description": "Full R1 (and R2 if run) response objects from all models" },
        "meta":             { "type": "object",  "description": "{ models: string[], duration_ms: number }" }
      },
      "tags": ["llm", "council", "multi-model", "deliberation", "claude", "gemini", "gpt"],
      "models": ["claude-3-haiku-20240307", "gemini-2.0-flash", "gpt-4o-mini"],
      "nodeCount": 28,
      "semanticDescription": "Submits a question or prompt to a three-model deliberation council (Claude, Gemini, and GPT) that reason independently in Round 1, then conduct peer review in Round 2 if agreement is not unanimous or confidence variance is high. Returns a synthesized final answer along with the consensus level, vote tally, each model's reasoning, any dissent, and optional clarifying questions and action items. Use this for high-stakes decisions, nuanced analysis, or any question where a single model's answer may be unreliable. Significantly more expensive and slower than a single-model call — prefer a direct LLM call for routine tasks.",
      "status": "active",
      "version": 1,
      "createdBy": "human",
      "nodeHash": null,
      "usageCount": 0,
      "lastVerified": "2026-02-19T00:00:00Z",
      "dependsOn": [],
      "allowedCallers": "any"
    },
    "Nexus.Builder": {
      "n8nId": "xXLHd1qN95ORknln",
      "description": "Creates and deploys new n8n workflows on demand from a spec",
      "semanticDescription": "Generates or modifies n8n workflow JSON using the Cortex LLM (Qwen3-Coder-30B W4A16 on the 4090), validates it (JSON parse, node whitelist, credential substitution, n8n API structural check), deploys via n8n REST API, activates the workflow, and returns the registry entry for external write. Use this when no existing workflow covers the requested task and a new one must be created autonomously.",
      "input": {
        "description":      { "type": "string",  "required": true,  "description": "What the workflow should do" },
        "domain":           { "type": "string",  "required": true,  "description": "Domain: email, llm, http, calendar, file, memory" },
        "required_inputs":  { "type": "object",  "required": true,  "description": "Input schema the new workflow must accept" },
        "expected_outputs": { "type": "object",  "required": true,  "description": "Output schema the new workflow must produce" },
        "similarity_match": { "type": "object",  "required": false, "description": "Existing workflow to modify (triggers MODIFY strategy)" }
      },
      "output": {
        "status":           { "type": "string",  "enum": ["success", "error"], "description": "Result status" },
        "workflowId":       { "type": "string",  "description": "n8n workflow ID of deployed workflow (null on error)" },
        "workflowName":     { "type": "string",  "description": "Name of the created workflow" },
        "deploymentStatus": { "type": "string",  "description": "unverified after initial deploy" },
        "registryEntry":    { "type": "object",  "description": "Complete registry entry object ready to write to workflow-registry.json" },
        "registryNote":     { "type": "string",  "description": "Instructions for external registry write" }
      },
      "tags": ["nexus", "builder", "meta", "orchestration", "llm", "cortex"],
      "llm": { "model": "Qwen3-Coder-30B-A3B W4A16", "endpoint": "http://192.168.1.140:8001", "purpose": "workflow generation" },
      "status": "active",
      "version": 1,
      "createdBy": "human+builder",
      "nodeHash": null,
      "usageCount": 0,
      "lastVerified": null,
      "dependsOn": [],
      "allowedCallers": "internal"
    },
    "Calendar.ListCalendars": {
      "n8nId": null,
      "description": "List all Google Calendars the authenticated user has access to",
      "semanticDescription": "Returns the full list of Google Calendars associated with the authenticated account, including personal calendars, shared calendars, and subscribed calendars. Each entry includes the calendar ID (needed by all other Calendar.* workflows), display name, timezone, access role, and whether it is the primary calendar. Use this workflow before any other Calendar operation when you do not already know the calendarId, or when the user asks 'which calendars do I have'. Takes no required inputs.",
      "input": {
        "showHidden": { "type": "boolean", "required": false, "description": "Include hidden or unsubscribed calendars (default false)" }
      },
      "output": {
        "calendars": { "type": "array",  "description": "Array of { calendarId, name, description, timezone, accessRole, primary, backgroundColor }" },
        "count":     { "type": "number", "description": "Total number of calendars returned" }
      },
      "tags": ["calendar", "google-calendar", "list", "meta"],
      "credentialRef": "gmail_main",
      "dangerous": false,
      "status": "inactive",
      "version": 1,
      "createdBy": "claude-code",
      "nodeHash": null,
      "usageCount": 0,
      "lastVerified": null,
      "dependsOn": [],
      "allowedCallers": "any"
    },
    "Calendar.List": {
      "n8nId": null,
      "description": "List upcoming Google Calendar events with optional date range, calendar, and text filters",
      "semanticDescription": "Queries a Google Calendar for events within a time window and returns a list of event summaries including title, start, end, location, and attendee count. Use this to answer questions like 'what do I have coming up this week' or 'show me all meetings tomorrow'. All inputs are optional — calling with no parameters returns the next 10 events on the primary calendar over the next 7 days. For a single specific event when you already have its ID, use Calendar.Get instead. For finding open time in the calendar, use Calendar.FindFreeSlot.",
      "input": {
        "calendarId":   { "type": "string",  "required": false, "description": "Calendar ID to query (default: 'primary')" },
        "timeMin":      { "type": "string",  "required": false, "description": "ISO 8601 lower bound for event start (default: now)" },
        "timeMax":      { "type": "string",  "required": false, "description": "ISO 8601 upper bound for event start (default: now + 7 days)" },
        "query":        { "type": "string",  "required": false, "description": "Free-text search across title, description, location, attendee names" },
        "limit":        { "type": "number",  "required": false, "description": "Max events to return (default 10, max 100)" },
        "singleEvents": { "type": "boolean", "required": false, "description": "Expand recurring events into individual instances (default true)" }
      },
      "output": {
        "events": { "type": "array",  "description": "Array of { eventId, calendarId, title, start, end, location, description, status, attendeeCount, isRecurring, htmlLink }" },
        "count":  { "type": "number", "description": "Total events returned" }
      },
      "tags": ["calendar", "google-calendar", "list", "events", "schedule"],
      "credentialRef": "gmail_main",
      "dangerous": false,
      "status": "inactive",
      "version": 1,
      "createdBy": "claude-code",
      "nodeHash": null,
      "usageCount": 0,
      "lastVerified": null,
      "dependsOn": [],
      "allowedCallers": "any"
    },
    "Calendar.Get": {
      "n8nId": null,
      "description": "Get a single Google Calendar event by ID",
      "semanticDescription": "Retrieves the complete details of one specific Google Calendar event by its event ID, including all attendees, the organizer, full description, location, recurrence rule, conference (Meet) link, and timestamps. Use this when you have a known event ID and need full event details. For browsing upcoming events without a known ID, use Calendar.List or Calendar.FindFreeSlot instead.",
      "input": {
        "eventId":    { "type": "string", "required": true,  "description": "Google Calendar event ID" },
        "calendarId": { "type": "string", "required": false, "description": "Calendar containing the event (default: 'primary')" }
      },
      "output": {
        "eventId":       { "type": "string",  "description": "Event ID" },
        "calendarId":    { "type": "string",  "description": "Calendar ID" },
        "title":         { "type": "string",  "description": "Event title" },
        "start":         { "type": "string",  "description": "ISO 8601 start datetime" },
        "end":           { "type": "string",  "description": "ISO 8601 end datetime" },
        "location":      { "type": "string",  "description": "Event location (null if not set)" },
        "description":   { "type": "string",  "description": "Event description (null if not set)" },
        "status":        { "type": "string",  "description": "'confirmed' | 'tentative' | 'cancelled'" },
        "attendees":     { "type": "array",   "description": "Array of { email, displayName, responseStatus }" },
        "organizer":     { "type": "object",  "description": "{ email, displayName }" },
        "isRecurring":   { "type": "boolean", "description": "True if part of a recurring series" },
        "htmlLink":      { "type": "string",  "description": "URL to open event in Google Calendar web UI" },
        "conferenceData":{ "type": "object",  "description": "Meet link info (null if no video conference)" }
      },
      "tags": ["calendar", "google-calendar", "get", "event"],
      "credentialRef": "gmail_main",
      "dangerous": false,
      "status": "inactive",
      "version": 1,
      "createdBy": "claude-code",
      "nodeHash": null,
      "usageCount": 0,
      "lastVerified": null,
      "dependsOn": [],
      "allowedCallers": "any"
    },
    "Calendar.Create": {
      "n8nId": null,
      "description": "Create a new Google Calendar event",
      "semanticDescription": "Creates a new event on Google Calendar with a title, start time, and end time. Supports optional description, location, attendee list, recurrence rules, Google Meet link generation, and color coding. Sending invitations to attendees is controlled by the sendUpdates field (default 'all' — attendees receive email invitations). Use this when the goal is to book a new meeting, appointment, or reminder. Do NOT use this to modify an existing event — use Calendar.Update. If you need to first check availability before creating, call Calendar.FindFreeSlot first then pass the chosen slot to this workflow.",
      "input": {
        "title":          { "type": "string",  "required": true,  "description": "Event title (summary)" },
        "start":          { "type": "string",  "required": true,  "description": "ISO 8601 start datetime" },
        "end":            { "type": "string",  "required": true,  "description": "ISO 8601 end datetime" },
        "calendarId":     { "type": "string",  "required": false, "description": "Target calendar ID (default: 'primary')" },
        "description":    { "type": "string",  "required": false, "description": "Event description (plain text or HTML)" },
        "location":       { "type": "string",  "required": false, "description": "Event location" },
        "attendees":      { "type": "array",   "required": false, "description": "Array of attendee email address strings" },
        "recurrence":     { "type": "array",   "required": false, "description": "RRULE strings, e.g. ['RRULE:FREQ=WEEKLY;COUNT=4']" },
        "sendUpdates":    { "type": "string",  "required": false, "description": "'all' | 'externalOnly' | 'none' (default 'all')" },
        "conferenceData": { "type": "boolean", "required": false, "description": "If true, attach a Google Meet link" }
      },
      "output": {
        "eventId":    { "type": "string", "description": "Newly created event ID" },
        "calendarId": { "type": "string", "description": "Calendar where event was created" },
        "title":      { "type": "string", "description": "Event title as saved" },
        "start":      { "type": "string", "description": "ISO 8601 start datetime" },
        "end":        { "type": "string", "description": "ISO 8601 end datetime" },
        "htmlLink":   { "type": "string", "description": "URL to open event in Google Calendar web UI" },
        "meetLink":   { "type": "string", "description": "Google Meet join URL (null if conferenceData was false)" },
        "status":     { "type": "string", "description": "'confirmed'" }
      },
      "tags": ["calendar", "google-calendar", "create", "event", "schedule", "book"],
      "credentialRef": "gmail_main",
      "dangerous": false,
      "status": "inactive",
      "version": 1,
      "createdBy": "claude-code",
      "nodeHash": null,
      "usageCount": 0,
      "lastVerified": null,
      "dependsOn": [],
      "allowedCallers": "any"
    },
    "Calendar.Update": {
      "n8nId": null,
      "description": "Modify fields on an existing Google Calendar event",
      "semanticDescription": "Updates one or more fields on an existing Google Calendar event identified by its event ID. Only the fields provided in the input are changed — all other fields are preserved (patch semantics). WARNING: the attendees field replaces the entire attendee list, not merges with it — if adding one attendee, first call Calendar.Get to retrieve the current list, then pass the full updated list to this workflow. Use Calendar.Delete to remove an event entirely.",
      "input": {
        "eventId":     { "type": "string", "required": true,  "description": "Event ID to update" },
        "calendarId":  { "type": "string", "required": false, "description": "Calendar containing the event (default: 'primary')" },
        "title":       { "type": "string", "required": false, "description": "New event title" },
        "start":       { "type": "string", "required": false, "description": "New ISO 8601 start datetime" },
        "end":         { "type": "string", "required": false, "description": "New ISO 8601 end datetime" },
        "description": { "type": "string", "required": false, "description": "New description" },
        "location":    { "type": "string", "required": false, "description": "New location" },
        "attendees":   { "type": "array",  "required": false, "description": "New complete attendee email list (replaces existing list)" },
        "sendUpdates": { "type": "string", "required": false, "description": "'all' | 'externalOnly' | 'none' (default 'all')" }
      },
      "output": {
        "eventId":    { "type": "string", "description": "Event ID" },
        "calendarId": { "type": "string", "description": "Calendar ID" },
        "title":      { "type": "string", "description": "Updated title" },
        "start":      { "type": "string", "description": "Updated start datetime" },
        "end":        { "type": "string", "description": "Updated end datetime" },
        "htmlLink":   { "type": "string", "description": "URL to open event in Google Calendar web UI" },
        "updated":    { "type": "string", "description": "ISO 8601 timestamp of this update" }
      },
      "tags": ["calendar", "google-calendar", "update", "event", "modify"],
      "credentialRef": "gmail_main",
      "dangerous": false,
      "status": "inactive",
      "version": 1,
      "createdBy": "claude-code",
      "nodeHash": null,
      "usageCount": 0,
      "lastVerified": null,
      "dependsOn": [],
      "allowedCallers": "any"
    },
    "Calendar.Delete": {
      "n8nId": null,
      "description": "Permanently delete a Google Calendar event",
      "semanticDescription": "Permanently and irreversibly deletes a Google Calendar event by its event ID. By default, cancellation notification emails are sent to all attendees. This action cannot be undone — deleted events cannot be recovered through n8n. Use Calendar.Update with status 'cancelled' instead if you want to cancel the event while keeping it visible in the calendar history. This is a DANGEROUS action — explicit confirmation is required before execution.",
      "input": {
        "eventId":     { "type": "string", "required": true,  "description": "Event ID to delete" },
        "calendarId":  { "type": "string", "required": false, "description": "Calendar containing the event (default: 'primary')" },
        "sendUpdates": { "type": "string", "required": false, "description": "Cancellation notification mode: 'all' (default), 'externalOnly', 'none'" }
      },
      "output": {
        "eventId": { "type": "string", "description": "The event ID that was deleted" },
        "status":  { "type": "string", "description": "'deleted'" }
      },
      "tags": ["calendar", "google-calendar", "delete", "event", "dangerous"],
      "credentialRef": "gmail_main",
      "dangerous": true,
      "status": "inactive",
      "version": 1,
      "createdBy": "claude-code",
      "nodeHash": null,
      "usageCount": 0,
      "lastVerified": null,
      "dependsOn": [],
      "allowedCallers": "any"
    },
    "Calendar.FindFreeSlot": {
      "n8nId": null,
      "description": "Find available time slots of a specified duration within a search window",
      "semanticDescription": "Queries the Google Calendar free/busy API for a given time window, then computes available time slots of the requested duration that fall within configurable working hours. Returns up to maxSlots candidate slots (default 5) aligned to 15-minute boundaries. Use this before Calendar.Create when you need to find a suitable meeting time — pass one of the returned slot start/end values directly to Calendar.Create. Does NOT book anything — it only reads availability. For simply listing existing events, use Calendar.List instead.",
      "input": {
        "durationMinutes":  { "type": "number",  "required": true,  "description": "Required slot length in minutes (e.g. 30, 60, 90)" },
        "searchStart":      { "type": "string",  "required": false, "description": "ISO 8601 start of search window (default: now)" },
        "searchEnd":        { "type": "string",  "required": false, "description": "ISO 8601 end of search window (default: now + 7 days)" },
        "calendarId":       { "type": "string",  "required": false, "description": "Calendar to check (default: 'primary')" },
        "workdayStartHour": { "type": "number",  "required": false, "description": "Working day start hour in local time (default 9)" },
        "workdayEndHour":   { "type": "number",  "required": false, "description": "Working day end hour in local time (default 17)" },
        "timezone":         { "type": "string",  "required": false, "description": "IANA timezone for workday bounds (default 'US/Central')" },
        "maxSlots":         { "type": "number",  "required": false, "description": "Max free slots to return (default 5)" }
      },
      "output": {
        "slots":    { "type": "array",  "description": "Array of { start, end, durationMinutes } representing available time slots" },
        "count":    { "type": "number", "description": "Number of free slots found" },
        "searched": { "type": "object", "description": "{ from: ISO, to: ISO } — the window that was searched" }
      },
      "tags": ["calendar", "google-calendar", "availability", "scheduling", "free-slot", "find"],
      "credentialRef": "gmail_main",
      "dangerous": false,
      "status": "inactive",
      "version": 1,
      "createdBy": "claude-code",
      "nodeHash": null,
      "usageCount": 0,
      "lastVerified": null,
      "dependsOn": [],
      "allowedCallers": "any"
    }
  }
}
